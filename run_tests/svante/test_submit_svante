#! /usr/bin/env bash

# $Header: /u/gcmpack/MITgcm_contrib/test_scripts/svante/test_submit_svante,v 1.23 2018/11/28 19:45:22 jmc Exp $
# $Name:  $

today=`date +%Y%m%d`
dInWeek=`date +%a`

if test $# = 0
then
  TEST_LIST='ifcMPI ifcAdm pgiMPI pgiAdm pgiMth'
else
  TEST_LIST=$*
fi

headNode=`hostname -s`
#QSUB="qsub"
#QSTAT="qstat -u $USER"
#dNam=$headNode
QSUB="/usr/bin/sbatch"
QLIST="/usr/bin/squeue -u $USER"
dNam='svante'
HERE="$HOME/test_${dNam}"
TST_DISK="/net/fs09/d1/jm_c"
TST_DIR="$TST_DISK/test_${dNam}"
tmpFil="/tmp/"`basename $0`".$$"
#- where local copy of code is (need to be consistent with run-job scripts):
#srcDIR=$TST_DIR
srcDIR=$HERE
srcCode="MITgcm_today"

logPfix='test_submit'
SUB_DIR="$HERE/$dNam"
OUT_DIR="$HERE/output"
LOG_FIL="$OUT_DIR/$logPfix."`date +%m%d`".log"
#SUB_DIR="$HERE/temp"

#-- clean up old log files and start a new one:
cd $OUT_DIR

rm -f $logPfix.*.log_bak
if test -f $LOG_FIL ; then mv -f $LOG_FIL ${LOG_FIL}_bak ; fi
echo -n '-- Starting: '					| tee -a $LOG_FIL
date							| tee -a $LOG_FIL

n=$(( `ls $logPfix.*.log | wc -l` - 10 ))
if test $n -gt 0 ; then
  echo ' remove old log files:'				| tee -a $LOG_FIL
    ls -lt $logPfix.*.log | tail -"$n"			| tee -a $LOG_FIL
    ls -t  $logPfix.*.log | tail -"$n" | xargs rm -f
fi

#-------------------------------------------------------------
# defaults
#export PATH="$PATH:/usr/local/bin"
if [ -d ~/bin ]; then export PATH=$PATH:~/bin ; fi
#- to get case insensitive "ls" (and order of tested experiments)
export LC_ALL="en_US.UTF-8"
#  Turn off stack limit for FIZHI & AD-tests
ulimit -s unlimited

if test -f /etc/profile.d/modules.sh    ; then . /etc/profile.d/modules.sh    ; fi
if test -f /etc/profile.d/zz_modules.sh ; then . /etc/profile.d/zz_modules.sh ; fi
#- load standard modules:
#module add fedora slurm maui svante
module add slurm
module list 						>> $LOG_FIL 2>&1

#- method to access CVS:
  cmdCVS='cvs -d :pserver:cvsanon@mitgcm.org:/u/gcmpack -q'
#- which GitHub repository to use and how to access it:
  git_repo='MITgcm';  git_code='MITgcm' ; git_other='verification_other'
 #git_repo='altMITgcm'; #git_code='MITgcm66h'
#--
  git_repo="https://github.com/$git_repo"
 #git_repo="git://github.com/$git_repo"
 #git_repo="git@github.com:$git_repo"

checkOut=1
addExp=''
updFile='updated_code'

#---+----1----+----2----+----3----+----4----+----5----+----6----+----7-|--+----|
if [ $checkOut -ge 1 ] ; then
#-- Download/Update reference version of MITgcm code:

  if test $srcDIR = $TST_DIR ; then
    echo "cd $TST_DISK ; pwd (x2)" | tee -a $LOG_FIL
    cd $TST_DISK	| tee -a $LOG_FIL 2>&1
    pwd			| tee -a $LOG_FIL
  fi
  if test ! -d $srcDIR ; then
     echo -n "Creating a working dir: $srcDIR ..."	| tee -a $LOG_FIL
    #/bin/rm -rf $srcDIR
     mkdir $srcDIR
     retVal=$?
     if test "x$retVal" != x0 ; then
       echo "Error: unable to make dir: $srcDIR (err=$retVal ) --> Exit" | tee -a $LOG_FIL
       exit 1
     fi
  fi
  cd $srcDIR
  pwd		| tee -a $LOG_FIL

  #- remove date/lock-file and old copy:
  if test -f $updFile ; then rm -f $updFile ; sleep 2 ; fi
  test -e $srcCode && rm -rf $srcCode

  if [ $checkOut -eq 1 ] ; then
    if test ! -e $git_code/.git/config ; then
      echo "no file: $git_code/.git/config => try a new clone"	| tee -a $LOG_FIL
      checkOut=2
    fi
    if test ! -e $git_other/.git/config ; then
      echo "no file: $git_other/.git/config => try a new clone"	| tee -a $LOG_FIL
      checkOut=2
    fi
  fi
  if [ $checkOut -eq 2 ] ; then
    if test -e $git_code ; then
       echo -n " removing dir: $git_code ..."		| tee -a $LOG_FIL
       rm -rf $git_code
       echo "  done"					| tee -a $LOG_FIL
    fi
    echo -n "Make a clone of $git_code from repo: $git_repo ..."	| tee -a $LOG_FIL
    git clone $git_repo/${git_code}.git 2> $tmpFil
    retVal=$?
    if test $retVal = 0 ; then
       echo ' --> done!'				| tee -a $LOG_FIL
       rm -f $tmpFil
    else echo ''					| tee -a $LOG_FIL
       echo " Error: 'git clone' returned: $retVal"	| tee -a $LOG_FIL
       cat $tmpFil ; rm -f $tmpFil
       exit 2
    fi
   #--
    if test -e $git_other ; then
       echo -n " removing dir: $git_other ..."		| tee -a $LOG_FIL
       rm -rf $git_other
       echo "  done"					| tee -a $LOG_FIL
    fi
    echo -n "Make a clone of $git_other from repo: $git_repo ..."	| tee -a $LOG_FIL
    git clone $git_repo/${git_other}.git 2> $tmpFil
    retVal=$?
    if test $retVal = 0 ; then
       echo ' --> done!'				| tee -a $LOG_FIL
       rm -f $tmpFil
    else echo ''					| tee -a $LOG_FIL
       echo " Error: 'git clone' returned: $retVal"	| tee -a $LOG_FIL
       cat $tmpFil ; rm -f $tmpFil
       exit 2
    fi
  fi
  #--
  if [ $checkOut -eq 1 ] ; then
    echo -n "Updating current clone ( $git_code ) ..."	| tee -a $LOG_FIL
    echo '' >> $LOG_FIL
    ( cd $git_code ; git pull )				>> $LOG_FIL 2>&1
    retVal=$?
    if test "x$retVal" != x0 ; then echo ''
         echo "'git pull' on '"`hostname`"' fail (return val=$retVal) => exit" | tee -a $LOG_FIL
         exit
    else echo "  done"					| tee -a $LOG_FIL
    fi
    echo "  and checkout master:"			| tee -a $LOG_FIL
    ( cd $git_code ; git checkout master -- . )		| tee -a $LOG_FIL
   #---
    echo -n "Updating current clone ( $git_other ) ..."	| tee -a $LOG_FIL
    echo '' >> $LOG_FIL
    ( cd $git_other ; git pull )			>> $LOG_FIL 2>&1
    retVal=$?
    if test "x$retVal" != x0 ; then echo ''
         echo "'git pull' on '"`hostname`"' fail (return val=$retVal) => exit" | tee -a $LOG_FIL
         exit
    else echo "  done"					| tee -a $LOG_FIL
    fi
    echo "  and checkout master:"			| tee -a $LOG_FIL
    ( cd $git_other ; git checkout master -- . )	| tee -a $LOG_FIL
  fi
  #---- making a new working copy: MITgcm_today
  rsync -a $git_code/ $srcCode --exclude '.git'
  ls -ld $srcCode					| tee -a $LOG_FIL
  /usr/bin/find $srcCode -type d | xargs chmod g+rxs
  /usr/bin/find $srcCode -type f | xargs chmod g+r
  #- update date/lock-file:
  if test -d $srcCode/verification ; then
    echo $today > $updFile ; sleep 2
    ls -l $updFile					| tee -a $LOG_FIL
    echo ''						| tee -a $LOG_FIL
  fi

#-- Done with Download/Update of MITgcm code
fi
#---+----1----+----2----+----3----+----4----+----5----+----6----+----7-|--+----|

#-- leave srcDIR and go back to output dir
cd $OUT_DIR
#-- now really do something:

  JOB_LIST=$TEST_LIST
  NB_SUB_JOBS=0
  for i in $JOB_LIST
  do
    case $i in
      'pgiMth') sfx='pgi_mth' ;;
             *) sfx=`echo ${i} | sed 's/MPI$/_mpi/' | sed 's/Adm$/_adm/'` ;;
    esac
    BATCH_SCRIPT="test_${dNam}_$sfx"
    if test -f $SUB_DIR/$BATCH_SCRIPT ; then
      #- job name ( $JOB ) & output-file name ( $JOB.std??? ) must match
      #  definition within $BATCH_SCRIPT slurm script
      JOB="${i}_tst"
      sJob=`printf "%8.8s" $JOB` #- squeue truncate name to only 1rst 8c
      #job_exist=`$QSTAT | grep $JOB | wc -l`
      job_exist=`$QLIST | grep $sJob | wc -l`
      if test "x_$job_exist" = x_0 ; then
        #-- move previous output file
        outList=`ls $JOB.std??? 2> /dev/null`
        if test "x$outList" != x ; then
          echo -n " moving job $JOB old output files:"	| tee -a $LOG_FIL
          if test -d $OUT_DIR/prev ; then
            for xx in $outList ; do
              pp=$OUT_DIR/prev/$xx ; echo -n " $xx"	| tee -a $LOG_FIL
              test -f $pp.sav && mv -f $pp.sav $pp.old
              test -f $pp     && mv -f $pp     $pp.sav
              chmod a+r $xx ; mv -f $xx $OUT_DIR/prev
            done
            echo " to dir ./prev"			| tee -a $LOG_FIL
          else
            echo " <-- missing dir $OUT_DIR/prev"	| tee -a $LOG_FIL
          fi
        else echo " no old output files from job '$JOB'" | tee -a $LOG_FIL
        fi
        #-- submit job
          echo -n "--> $JOB : "				| tee -a $LOG_FIL
          $QSUB $SUB_DIR/$BATCH_SCRIPT			| tee -a $LOG_FIL
          NB_SUB_JOBS=`expr $NB_SUB_JOBS + 1`
          sleep 1
      else
          echo "--> $JOB :"				| tee -a $LOG_FIL
          #$QSTAT | grep $JOB				| tee -a $LOG_FIL
          $QLIST | grep $sJob				| tee -a $LOG_FIL
          echo ' job already exist => skip this test'	| tee -a $LOG_FIL
      fi
    else
       echo 'no file:' $BATCH_SCRIPT 'to submit'	| tee -a $LOG_FIL
    fi
  done
  echo "info-sub-list: NB_SUB_JOBS='$NB_SUB_JOBS'"	>> $LOG_FIL
  echo -n '-- Finished at: '				| tee -a $LOG_FIL
  date							| tee -a $LOG_FIL

#---+----1----+----2----+----3----+----4----+----5----+----6----+----7-|--+----|
exit 0
